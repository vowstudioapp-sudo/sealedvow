import crypto from 'crypto';
import { Redis } from "@upstash/redis";
import admin from "firebase-admin";

const kv = new Redis({
  url: process.env.KV_REST_API_URL,
  token: process.env.KV_REST_API_TOKEN,
});

if (!admin.apps.length) {
  admin.initializeApp({
    credential: admin.credential.cert({
      projectId: process.env.FIREBASE_PROJECT_ID,
      clientEmail: process.env.FIREBASE_CLIENT_EMAIL,
      privateKey: process.env.FIREBASE_PRIVATE_KEY?.replace(/\\n/g, '\n'),
    }),
    databaseURL: process.env.FIREBASE_DB_URL,
  });
}

const adminDb = admin.database();

// ============================================================================
// /api/verify-payment.js — SERVER-SIDE AUTHORITY (HARDENED)
//
// Two paths:
//   A) Founder: paymentMode === 'founder' + founderToken (server-generated nonce)
//   B) Razorpay: standard signature verification
//
// Security: Founder path requires a one-time token generated by create-order
// to prevent frontend-only bypass. Token is consumed on use.
// ============================================================================

const TIER_PRICES = {
  standard: 9900,
  reply: 14900,
};

const ALLOWED_ORIGINS = [
  "https://www.sealedvow.com",
  "https://sealedvow.com",
  "https://sealedvow.vercel.app"
];

function setCors(req, res) {
  const origin = req.headers.origin;

  if (origin && ALLOWED_ORIGINS.includes(origin)) {
    res.setHeader("Access-Control-Allow-Origin", origin);
  }

  res.setHeader("Access-Control-Allow-Methods", "POST, OPTIONS");
  res.setHeader("Access-Control-Allow-Headers", "Content-Type");
  res.setHeader("Vary", "Origin");
}

function getClientIP(req) {
  return (
    req.headers["x-forwarded-for"]?.split(",")[0]?.trim() ||
    req.headers["x-real-ip"] ||
    req.socket?.remoteAddress ||
    "unknown"
  );
}

function generateShortId() {
  const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
  const bytes = crypto.randomBytes(8);
  let result = '';
  for (let i = 0; i < 8; i++) {
    result += chars[bytes[i] % chars.length];
  }
  return result;
}

function slugify(text) {
  return text
    .toLowerCase()
    .trim()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '')
    .substring(0, 30);
}

function validateCoupleData(data) {
  if (!data || typeof data !== 'object') return null;

  const raw = JSON.stringify(data);
  if (raw.length > 200_000) return null;

  if (typeof data.recipientName !== 'string' || data.recipientName.trim().length === 0) return null;
  if (typeof data.senderName !== 'string' || data.senderName.trim().length === 0) return null;

  const validOccasions = ['valentine', 'anniversary', 'apology', 'just-because', 'long-distance', 'thank-you'];
  if (!validOccasions.includes(data.occasion)) return null;

  const validThemes = ['obsidian', 'velvet', 'crimson', 'midnight', 'evergreen', 'pearl'];
  if (!validThemes.includes(data.theme)) return null;

  const sanitized = {};
  const MAX_STRING = 10000;
  const MAX_NAME = 100;

  for (const [key, value] of Object.entries(data)) {
    if (typeof value === 'string') {
      let clean = value
        .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '')
        .replace(/javascript:/gi, '')
        .replace(/on\w+\s*=/gi, '');
      clean = (key === 'recipientName' || key === 'senderName')
        ? clean.substring(0, MAX_NAME).trim()
        : clean.substring(0, MAX_STRING);
      sanitized[key] = clean;
    } else if (Array.isArray(value)) {
      sanitized[key] = value.slice(0, 10);
    } else if (typeof value === 'boolean' || typeof value === 'number') {
      sanitized[key] = value;
    } else if (value !== null && typeof value === 'object') {
      sanitized[key] = value;
    }
  }

  return sanitized;
}


// ══════════════════════════════════════════════════════════════════════
// MAIN HANDLER
// ══════════════════════════════════════════════════════════════════════

export default async function handler(req, res) {
  setCors(req, res);

  if (req.method === 'OPTIONS') return res.status(200).end();
  if (req.method !== 'POST') return res.status(405).json({ error: 'Method not allowed' });

  if (!req.headers['content-type']?.includes('application/json')) {
    return res.status(415).json({ error: 'Unsupported Media Type' });
  }

  // ── GLOBAL IP RATE LIMITING ──
  const RATE_LIMIT_WINDOW = 60;
  const MAX_REQUESTS = 5;

  try {
    const ip = getClientIP(req);
    const key = `payment_rate:${ip}`;
    const current = await kv.incr(key);

    if (current === 1) {
      await kv.expire(key, RATE_LIMIT_WINDOW);
    }

    if (current > MAX_REQUESTS) {
      return res.status(429).json({
        error: "Too many requests. Please wait a minute."
      });
    }
  } catch (kvError) {
    console.error("[PaymentRateLimit] KV unavailable:", kvError.message);
    return res.status(503).json({
      error: "Service temporarily unavailable. Please try again."
    });
  }

  const {
    razorpay_order_id,
    razorpay_payment_id,
    razorpay_signature,
    coupleData,
    tier,
    paymentMode,
    founderToken,
  } = req.body || {};

  // ════════════════════════════════════════════════════════════
  // PATH A: FOUNDER ACCESS
  // Requires founderToken that was stored in Firebase by create-order.
  // Token is single-use: read once, delete immediately.
  // This prevents frontend from faking paymentMode=founder.
  // ════════════════════════════════════════════════════════════
  if (paymentMode === 'founder') {
    if (!founderToken || typeof founderToken !== 'string') {
      return res.status(400).json({ verified: false, error: 'Invalid request.' });
    }
    if (!coupleData || typeof coupleData !== 'object') {
      return res.status(400).json({ verified: false, error: 'Missing session data.' });
    }

    try {
      // Verify and consume the one-time token
      const tokenRef = adminDb.ref('founderTokens/' + founderToken);
      const tokenSnap = await tokenRef.once('value');
      const tokenData = tokenSnap.val();

      if (!tokenData || tokenData.consumed) {
        return res.status(400).json({ verified: false, error: 'Invalid request.' });
      }

      if (Date.now() - tokenData.createdAt > 5 * 60 * 1000) {
        await tokenRef.remove().catch(() => {});
        return res.status(400).json({ verified: false, error: 'Session expired. Please try again.' });
      }

      await tokenRef.remove();

      const sanitized = validateCoupleData(coupleData);
      if (!sanitized) {
        return res.status(400).json({ verified: false, error: 'Invalid session data.' });
      }

      const validTier = TIER_PRICES[tokenData.tier] ? tokenData.tier : 'reply';
      const replyEnabled = validTier === 'reply';

      // Generate session key
      let sessionKey = '';
      for (let attempt = 0; attempt < 5; attempt++) {
        sessionKey = generateShortId();
        try {
          const existsSnap = await adminDb.ref('shared/' + sessionKey).once('value');
          const exists = existsSnap.val();
          if (!exists) break;
        } catch { break; }
        if (attempt === 4) {
          return res.status(500).json({ verified: false, error: 'Session creation failed. Please retry.' });
        }
      }

      const now = new Date().toISOString();
      const founderId = `founder_${Date.now()}`;

      const updates = {};
      updates[`shared/${sessionKey}`] = {
        ...sanitized,
        replyEnabled,
        status: 'paid',
        sealedAt: now,
        createdAt: sanitized.createdAt || now,
        paymentId: founderId,
        paymentMode: 'founder',
        paidAmount: 0,
        tier: validTier,
      };

      updates[`payments/${founderId}`] = {
        paymentId: founderId,
        paymentMode: 'founder',
        amount: 0,
        tier: validTier,
        replyEnabled,
        sessionKey,
        verifiedAt: now,
      };

      await adminDb.ref().update(updates);

      const senderSlug = slugify(sanitized.senderName || 'sender');
      const receiverSlug = slugify(sanitized.recipientName || 'receiver');
      const shareSlug = `${senderSlug}-${receiverSlug}-${sessionKey}`;

      console.log(`[Verify] ✓ FOUNDER ${sessionKey} | ${founderId} | ${validTier}`);

      return res.status(200).json({
        verified: true,
        sessionKey,
        shareSlug,
        replyEnabled,
        paymentId: founderId,
      });
    } catch (error) {
      console.error('[Verify] Founder error:', error);
      return res.status(500).json({ verified: false, error: 'Session creation failed.' });
    }
  }

  // ════════════════════════════════════════════════════════════
  // PATH B: NORMAL RAZORPAY FLOW
  // ════════════════════════════════════════════════════════════
  if (!razorpay_order_id || !razorpay_payment_id || !razorpay_signature) {
    return res.status(400).json({ verified: false, error: 'Missing payment fields.' });
  }
  if (!coupleData || typeof coupleData !== 'object') {
    return res.status(400).json({ verified: false, error: 'Missing session data.' });
  }

  const keySecret = process.env.RAZORPAY_KEY_SECRET;

  if (!keySecret) {
    console.error('[Verify] Missing RAZORPAY_KEY_SECRET');
    return res.status(500).json({ verified: false, error: 'Server configuration error.' });
  }

  try {
    // 1. VERIFY RAZORPAY SIGNATURE
    const body = razorpay_order_id + '|' + razorpay_payment_id;
    const expected = crypto.createHmac('sha256', keySecret).update(body).digest('hex');

    let isValid;
    try {
      isValid = crypto.timingSafeEqual(
        Buffer.from(expected, 'hex'),
        Buffer.from(razorpay_signature, 'hex'),
      );
    } catch {
      isValid = false;
    }

    if (!isValid) {
      console.warn(`[Verify] Signature mismatch: ${razorpay_order_id}`);
      return res.status(400).json({ verified: false, error: 'Payment verification failed.' });
    }

    // 2. REPLAY PROTECTION
    try {
      const existingSnap = await adminDb.ref('payments/' + razorpay_payment_id).once('value');
      const existing = existingSnap.val();
      if (existing && existing.sessionKey) {
        const s = slugify(coupleData.senderName || 'sender');
        const r = slugify(coupleData.recipientName || 'receiver');
        return res.status(200).json({
          verified: true,
          replay: true,
          sessionKey: existing.sessionKey,
          shareSlug: `${s}-${r}-${existing.sessionKey}`,
          replyEnabled: existing.replyEnabled || false,
          paymentId: razorpay_payment_id,
        });
      }
    } catch (e) {
      console.warn('[Verify] Replay check failed, proceeding:', e.message);
    }

    // 3. RESOLVE AMOUNT FROM ORDER
    let orderAmount = null;
    let orderTier = tier || 'standard';

    try {
      const orderSnap = await adminDb.ref('orders/' + razorpay_order_id).once('value');
      const orderData = orderSnap.val();
      if (orderData && orderData.amount) {
        orderAmount = orderData.amount;
        orderTier = orderData.tier || orderTier;
      }
    } catch {
      console.warn('[Verify] Order lookup failed, using tier fallback');
    }

    const validTier = TIER_PRICES[orderTier] ? orderTier : 'standard';
    if (!orderAmount) orderAmount = TIER_PRICES[validTier];
    const replyEnabled = validTier === 'reply';

    // 4. VALIDATE COUPLE DATA
    const sanitized = validateCoupleData(coupleData);
    if (!sanitized) {
      return res.status(400).json({ verified: false, error: 'Invalid session data.' });
    }

    // 5. GENERATE SESSION KEY
    let sessionKey = '';
    for (let attempt = 0; attempt < 5; attempt++) {
      sessionKey = generateShortId();
      try {
        const existsSnap = await adminDb.ref('shared/' + sessionKey).once('value');
        const exists = existsSnap.val();
        if (!exists) break;
      } catch {
        break;
      }
      if (attempt === 4) {
        return res.status(500).json({ verified: false, error: 'Session creation failed. Please retry.' });
      }
    }

    // 6. ATOMIC MULTI-PATH WRITE
    const now = new Date().toISOString();

    const updates = {};

    updates[`shared/${sessionKey}`] = {
      ...sanitized,
      replyEnabled,
      status: 'paid',
      sealedAt: now,
      createdAt: sanitized.createdAt || now,
      paymentId: razorpay_payment_id,
      orderId: razorpay_order_id,
      tier: validTier,
    };

    updates[`payments/${razorpay_payment_id}`] = {
      orderId: razorpay_order_id,
      paymentId: razorpay_payment_id,
      amount: orderAmount,
      tier: validTier,
      replyEnabled,
      sessionKey,
      verifiedAt: now,
    };

    updates[`orders/${razorpay_order_id}/status`] = 'paid';

    await adminDb.ref().update(updates);

    // 7. RETURN SHARE URL
    const senderSlug = slugify(sanitized.senderName || 'sender');
    const receiverSlug = slugify(sanitized.recipientName || 'receiver');
    const shareSlug = `${senderSlug}-${receiverSlug}-${sessionKey}`;

    console.log(`[Verify] ✓ ${sessionKey} | ${razorpay_payment_id} | ${validTier}`);

    return res.status(200).json({
      verified: true,
      sessionKey,
      shareSlug,
      replyEnabled,
      paymentId: razorpay_payment_id,
    });

  } catch (error) {
    console.error('[Verify] Error:', error);
    return res.status(500).json({ verified: false, error: 'Verification system error.' });
  }
}